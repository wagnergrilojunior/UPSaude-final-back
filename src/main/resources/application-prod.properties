    # ============================================
    # Spring Boot DevTools - DESABILITADO em PROD
    # ============================================
    # DevTools deve ser usado apenas no ambiente local
    spring.devtools.restart.enabled=false
    spring.devtools.livereload.enabled=false
    spring.devtools.remote.restart.enabled=false

    # Configurações do Servidor
    server.port=8080
    server.servlet.context-path=/api

    # URL do servidor para Swagger/OpenAPI
    springdoc.api-server-url=https://api.upsaude.wgbsolucoes.com.br/api

    # Configurações do Banco de Dados
    spring.datasource.url=jdbc:postgresql://aws-1-sa-east-1.pooler.supabase.com:6543/postgres?sslmode=require
    spring.datasource.username=postgres.pririvdtylilyrtfbmmv
    spring.datasource.password=nu3ZmC8pChEm82Xi
    spring.datasource.driver-class-name=org.postgresql.Driver

    # Configurações do Pool de Conexões HikariCP (otimizado para evitar limite do Supabase)
    # IMPORTANTE: Configurações agressivas para matar conexões lentas/ociosas rapidamente
    spring.datasource.hikari.maximum-pool-size=4
    spring.datasource.hikari.minimum-idle=1
    # Idle timeout reduzido: conexões ociosas são fechadas após 15 segundos
    spring.datasource.hikari.idle-timeout=15000
    # Max lifetime reduzido: conexões são forçadas a fechar após 120 segundos (2 minutos)
    spring.datasource.hikari.max-lifetime=120000
    # Keepalive: mantém conexões vivas, mas não impede o fechamento por idle-timeout
    spring.datasource.hikari.keepalive-time=30000
    # Connection timeout reduzido: falha rápido se não conseguir conexão
    spring.datasource.hikari.connection-timeout=10000
    # Validation timeout: valida conexões rapidamente
    spring.datasource.hikari.validation-timeout=3000
    # Leak detection: detecta vazamentos de conexão em 10 segundos
    spring.datasource.hikari.leak-detection-threshold=10000
    # Housekeeping period: limpeza do pool a cada 10 segundos (padrão é 30s)
    spring.datasource.hikari.housekeeping-period-ms=10000
    # Pool name para identificação
    spring.datasource.hikari.pool-name=UpSaudeHikariPool-Prod
    # Query de teste para validar conexões
    spring.datasource.hikari.connection-test-query=SELECT 1
    # NOTA: Prepared statements e validação de conexão são configurados via DataSourceConfig.java

    # Configuração JPA para dev
    spring.jpa.hibernate.ddl-auto=none
    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
    spring.jpa.show-sql=false
    spring.jpa.properties.hibernate.format_sql=false
    # IMPORTANTE: Desabilitar open-in-view para evitar manter conexões abertas durante requisições HTTP
    spring.jpa.open-in-view=false
    # Permite que o Hibernate continue mesmo com erros de DDL (para conversões de tipo que requerem USING)
    spring.jpa.properties.hibernate.tool.schema.halt_on_error=false
    # Configurações para gerenciamento de transações e prepared statements
    spring.jpa.properties.hibernate.connection.provider_disables_autocommit=false
    spring.jpa.properties.hibernate.jdbc.batch_size=20
    spring.jpa.properties.hibernate.order_inserts=true
    spring.jpa.properties.hibernate.order_updates=true

    # Configurações do Supabase
    supabase.url=${SUPABASE_URL:https://pririvdtylilyrtfbmmv.supabase.co}
    supabase.anon-key=${SUPABASE_ANON_KEY:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InByaXJpdmR0eWxpbHlydGZibW12Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM3NDk3OTYsImV4cCI6MjA3OTMyNTc5Nn0.QFu4AzIltRfXba3gg4u_DBuOf-r55KhoCuwbBuO2ULw}
    supabase.service-role-key=${SUPABASE_SERVICE_ROLE_KEY:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InByaXJpdmR0eWxpbHlydGZibW12Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2Mzc0OTc5NiwiZXhwIjoyMDc5MzI1Nzk2fQ.6VaENvPSOSUTOQ3aRPPre8tGJ8ktme_5CU5hravHdsU}

    # Configurações do OpenAPI/Swagger
    springdoc.api-docs.path=/api-docs
    springdoc.swagger-ui.path=/swagger-ui.html
    springdoc.swagger-ui.operationsSorter=method
    springdoc.swagger-ui.tagsSorter=alpha

    # Configurações do Jackson para suporte a datas Java 17 (java.time.*)
    spring.jackson.serialization.write-dates-as-timestamps=false
    spring.jackson.deserialization.fail-on-unknown-properties=false

    # Configurações do Redis/Valkey para Cache (Produção)
    # Compatível com Redis e Valkey (fork do Redis usado pelo Render)
    # Usa variáveis de ambiente para flexibilidade no Render
    spring.redis.host=${REDIS_HOST:upsaude-redis}
    spring.redis.port=${REDIS_PORT:6379}
    spring.redis.password=${REDIS_PASSWORD:UPS@ude2026PM_SRS}
    spring.redis.ssl.enabled=false
    spring.redis.timeout=50000ms
    spring.redis.lettuce.pool.max-active=8
    spring.redis.lettuce.pool.max-idle=8
    spring.redis.lettuce.pool.min-idle=0
    
    # ============================================
    # Configurações de Métricas do Redis para Observabilidade
    # ============================================
    # CORREÇÃO: Desabilitar métricas problemáticas do Redis/Lettuce que causam erro 500 no endpoint /metrics
    # Estas métricas causam exceções ao tentar coletar todas as métricas de uma vez
    # Habilita métricas do Redis (conexões, comandos, latência) - DESABILITADO para evitar erro 500
    management.metrics.enable.redis=false
    # Habilita métricas do cliente Lettuce (pool de conexões, comandos) - DESABILITADO para evitar erro 500
    management.metrics.enable.lettuce=false
    # Habilita métricas do cache Spring (hit/miss, tamanho, evictions) - MANTIDO (funciona corretamente)
    management.metrics.enable.cache=true
    # Habilita métricas do Spring Data Redis (repositories, operações) - DESABILITADO para evitar erro 500
    management.metrics.enable.spring-data=false
    # Tags adicionais para identificação nas métricas
    management.metrics.tags.application=upsaude-backend
    management.metrics.tags.environment=production
    # Distribuição de estatísticas para métricas de latência (histogramas) - Apenas cache (funciona)
    management.metrics.distribution.percentiles-histogram.cache.get=true
    management.metrics.distribution.percentiles-histogram.cache.put=true
    # Percentis específicos para análise de latência (p50, p95, p99) - Apenas cache
    management.metrics.distribution.percentiles.cache.get=0.5,0.95,0.99
    management.metrics.distribution.percentiles.cache.put=0.5,0.95,0.99
    # SLOs (Service Level Objectives) para alertas baseados em latência - Apenas cache
    management.metrics.distribution.slo.cache.get=10ms,50ms,100ms
    management.metrics.distribution.slo.cache.put=10ms,50ms,100ms

    # Configurações para não bloquear startup se Redis não estiver disponível
    spring.redis.lettuce.shutdown-timeout=10000ms
    spring.data.redis.repositories.enabled=false

    # Configurações do Cache Manager
    spring.cache.redis.time-to-live=300000
    spring.cache.redis.key-prefix=upsaude::
    spring.cache.type=redis
    spring.cache.redis.cache-null-values=false
    # Health check do banco de dados habilitado em prod
    management.health.db.enabled=true
    # Health check do Redis não bloqueia startup se não disponível
    # IMPORTANTE: Redis não é crítico - aplicação funciona sem cache
    management.health.redis.enabled=true
    management.health.redis.timeout=30000ms
    # Health check groups para endpoints mais leves
    # Health principal não depende do banco para evitar conexões extras
    management.endpoint.health.group.default.include=ping
    # Liveness: apenas verifica se a aplicação está rodando (ping)
    # Readiness: verifica se está pronto para receber tráfego (db apenas)
    management.endpoint.health.group.liveness.include=ping
    management.endpoint.health.group.readiness.include=db
    # Redis não está no readiness para não bloquear startup
    # Timeout geral do health check endpoint (aumentado para produção)
    management.endpoint.health.timeout=50000ms
    # Health check mais rápido em produção - sem detalhes
    management.endpoint.health.show-details=never
    # Base path do actuator (sem /api)
    management.endpoints.web.base-path=/actuator
    # Desativa métricas JDBC para evitar conexões extras
    # NOTA: Todas as outras métricas (HTTP, JVM, Cache, customizadas) continuam funcionando normalmente
    management.metrics.jdbc.datasource.enabled=false
    # Garante que métricas HTTP, JVM e cache continuem habilitadas
    management.metrics.jvm.enabled=true
    management.metrics.web.server.auto-time-requests=true
    management.metrics.cache.enabled=true

    # ============================================
    # Configurações do Spring Boot Admin (Produção)
    # ============================================
    # URL do servidor Spring Boot Admin (ÚNICO servidor para dev e prod)
    # IMPORTANTE: Incluir /admin no final (context-path do Admin Server)
    spring.boot.admin.client.url=${SPRING_BOOT_ADMIN_URL:https://admin.upsaude.wgbsolucoes.com.br/admin}
    # Nome da instância para identificação no painel
    spring.boot.admin.client.instance.name=UPSaude Backend - PROD
    # URL base da aplicação para o Admin Server acessar os endpoints
    spring.boot.admin.client.instance.service-base-url=https://api.upsaude.wgbsolucoes.com.br

    # ============================================
    # Configurações de Logging para Produção
    # ============================================
    # Reduz verbosidade em produção para melhor performance
    logging.level.root=INFO
    logging.level.com.upsaude=INFO
    logging.level.org.springframework=INFO
    logging.level.org.hibernate.SQL=WARN
    logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN
    logging.level.com.zaxxer.hikari=WARN
    logging.level.org.springframework.web=INFO
    logging.level.org.springframework.security=WARN
    # Logging do Spring Boot Admin Client para diagnóstico
    logging.level.de.codecentric.boot.admin.client=INFO
    logging.level.de.codecentric.boot.admin.client.registration=DEBUG
